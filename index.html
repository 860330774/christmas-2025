<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Magical Christmas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* ç¦æ­¢æ»šåŠ¨æ¡ */
            background-color: #050505;
            height: 100vh;
            width: 100vw;
            cursor: none; /* ç”µè„‘ç«¯éšè—é¼ æ ‡ */
            user-select: none;
            -webkit-user-select: none; /* å…¼å®¹ Safari */
            touch-action: none; /* å…³é”®ï¼šç¦æ­¢æ‰€æœ‰é»˜è®¤è§¦æ‘¸è¡Œä¸ºï¼ˆå¦‚æ»šåŠ¨ã€å›å¼¹ï¼‰ */
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
        }

        #bgCanvas { z-index: 1; }
        #fogCanvas { z-index: 10; }

        .guide {
            position: absolute;
            bottom: 10%; left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.4);
            font-family: sans-serif;
            font-size: 14px;
            letter-spacing: 2px;
            pointer-events: none;
            z-index: 11;
            white-space: nowrap; /* é˜²æ­¢æ–‡å­—æ¢è¡Œ */
            animation: fadeOut 4s forwards 2s;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        @keyframes fadeOut { to { opacity: 0; } }

        .falling-item {
            position: absolute;
            pointer-events: none;
            font-size: 24px;
            z-index: 9999;
            will-change: transform, opacity;
            filter: drop-shadow(0 0 2px rgba(255,255,255,0.5));
        }

        #cursor-glow {
            position: absolute;
            width: 80px; height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 9998;
            mix-blend-mode: screen;
            /* æ‰‹æœºç«¯éšè—å…‰æ ‡ï¼Œå› ä¸ºæ‰‹æŒ‡ä¼šæŒ¡ä½ */
            display: none; 
        }

        /* ä»…åœ¨æ”¯æŒ hover çš„è®¾å¤‡ï¼ˆç”µè„‘ï¼‰ä¸Šæ˜¾ç¤ºå…‰æ ‡ */
        @media (hover: hover) {
            #cursor-glow { display: block; }
        }
    </style>
</head>
<body>

    <canvas id="bgCanvas"></canvas>
    <canvas id="fogCanvas"></canvas>
    <div class="guide">åœ¨å±å¹•ä¸Šæ»‘åŠ¨ï¼Œç‚¹äº®åœ£è¯æ ‘...</div>
    <div id="cursor-glow"></div>

    <script>
        // === å…¨å±€å˜é‡ ===
        let width, height, dpr;

        // === 1. é™æ€èƒŒæ™¯å±‚ (æ ‘ + å­—) ===
        const bgCvs = document.getElementById('bgCanvas');
        const bCtx = bgCvs.getContext('2d');

        // æ ¸å¿ƒï¼šå¤„ç†é«˜æ¸…å± (Retina) å’Œ å°ºå¯¸é‡ç½®
        function resizeCanvas(canvas, ctx) {
            width = window.innerWidth;
            height = window.innerHeight;
            dpr = window.devicePixelRatio || 1;

            // è®¾ç½®ç‰©ç†åƒç´ å¤§å° (æ¸…æ™°åº¦å…³é”®)
            canvas.width = width * dpr;
            canvas.height = height * dpr;

            // è®¾ç½® CSS æ˜¾ç¤ºå¤§å°
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            // ç»Ÿä¸€ç¼©æ”¾ä¸Šä¸‹æ–‡ï¼Œåé¢ç”»ç”»æ—¶ç›´æ¥ç”¨é€»è¾‘åæ ‡
            ctx.scale(dpr, dpr);
        }

        function initBackground() {
            resizeCanvas(bgCvs, bCtx);

            // èƒŒæ™¯æ¸å˜
            const gradient = bCtx.createRadialGradient(width/2, height/2, 0, width/2, height/2, Math.max(width, height));
            gradient.addColorStop(0, '#1a0b2e'); 
            gradient.addColorStop(1, '#000000'); 
            bCtx.fillStyle = gradient;
            bCtx.fillRect(0, 0, width, height);

            drawStaticTree();
            drawArtText();
        }

        function drawStaticTree() {
            // é€‚é…é€»è¾‘ï¼šåŸºäºå±å¹•è¾ƒçŸ­çš„ä¸€è¾¹æ¥è®¡ç®—æ ‘çš„å¤§å°
            // è¿™æ ·åœ¨è¶…å®½å±ä¸Šæ ‘ä¸ä¼šå¤ªèƒ–ï¼Œåœ¨æ‰‹æœºä¸Šæ ‘ä¸ä¼šç”»å‡ºå±å¹•
            const minDim = Math.min(width, height);
            
            // æ ‘çš„é«˜åº¦å æ¯”
            const startY = height * 0.2; // é¡¶éƒ¨ç•™ç©º
            const endY = height * 0.85;  // åº•éƒ¨ç•™ç©º
            const treeHeight = endY - startY;

            bCtx.save();
            bCtx.shadowBlur = 15;
            bCtx.shadowColor = "gold";
            
            // å¢åŠ ç²’å­å¯†åº¦
            for (let i = 0; i < 500; i++) {
                const yRatio = Math.random();
                const y = startY + yRatio * treeHeight;
                
                // æ ‘çš„å®½åº¦ï¼šåŸºäº minDim è®¡ç®—ï¼Œä¿è¯æ¯”ä¾‹åè°ƒ
                // æ‰‹æœºç«¯ç¨å¾®å®½ä¸€ç‚¹ (0.35)ï¼Œç”µè„‘ç«¯æ­£å¸¸
                const widthFactor = width < height ? 0.35 : 0.25;
                const maxRadius = 10 + yRatio * (minDim * widthFactor * 2);

                const angle = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * maxRadius;
                const x = width/2 + Math.cos(angle) * r; // æ°¸è¿œå±…ä¸­
                
                const colors = ['#FFD700', '#FF3333', '#33FF33', '#FFFFFF'];
                const color = colors[Math.floor(Math.random() * colors.length)];

                bCtx.beginPath();
                bCtx.fillStyle = color;
                bCtx.arc(x, y, Math.random() * 3 + 1, 0, Math.PI*2);
                bCtx.fill();
            }
            
            // æ˜Ÿæ˜Ÿ
            bCtx.shadowBlur = 30;
            bCtx.shadowColor = "#ffff00";
            bCtx.fillStyle = "#ffffaa";
            bCtx.beginPath();
            // æ˜Ÿæ˜Ÿå¤§å°ä¹Ÿè‡ªé€‚åº”
            bCtx.arc(width/2, startY - 15, minDim * 0.03, 0, Math.PI*2);
            bCtx.fill();
            bCtx.restore();
        }

        function drawArtText() {
            bCtx.save();
            // é€‚é…é€»è¾‘ï¼šå­—ä½“å¤§å°åŸºäºå±å¹•å®½åº¦ï¼Œä½†è®¾æœ‰ä¸Šé™å’Œä¸‹é™
            let fontSize = width < height ? width * 0.15 : height * 0.15;
            // é™åˆ¶æœ€å¤§å­—å·ï¼Œé˜²æ­¢å¸¦é±¼å±ä¸Šå­—å¤ªå¤§
            if (fontSize > 150) fontSize = 150;

            bCtx.font = `bold italic ${fontSize}px "Brush Script MT", cursive, serif`;
            bCtx.textAlign = "center";
            bCtx.textBaseline = "middle";
            
            bCtx.shadowColor = "#ff00de";
            bCtx.shadowBlur = 30;
            bCtx.fillStyle = "rgba(255, 0, 222, 0.3)";
            bCtx.fillText("Merry Christmas", width/2, height/2);

            bCtx.shadowBlur = 10;
            bCtx.fillStyle = "#fff";
            bCtx.fillText("Merry Christmas", width/2, height/2);
            bCtx.restore();
        }


        // === 2. åŠ¨æ€é›¾æ°”å±‚ ===
        const fogCvs = document.getElementById('fogCanvas');
        const fCtx = fogCvs.getContext('2d');
        const maskCvs = document.createElement('canvas');
        const mCtx = maskCvs.getContext('2d');

        let bubbles = [];
        let lastPos = null;

        class Bubble {
            constructor() {
                this.init();
            }
            init() {
                this.x = Math.random() * width;
                this.y = height + Math.random() * 100;
                this.radius = Math.random() * 10 + 5;
                this.speed = Math.random() * 1.5 + 0.5;
                this.opacity = Math.random() * 0.4 + 0.1;
                this.wobble = Math.random() * Math.PI * 2;
            }
            update() {
                this.y -= this.speed;
                this.wobble += 0.03;
                this.x += Math.sin(this.wobble) * 0.5;
                if (this.y < -20) this.init();
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fillStyle = `rgba(200, 230, 255, ${this.opacity})`;
                ctx.fill();
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity + 0.1})`;
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
        }

        function initFog() {
            resizeCanvas(fogCvs, fCtx);
            
            // ç¦»å±Canvasä¹Ÿéœ€è¦é€‚é…å°ºå¯¸ï¼Œå¦åˆ™åˆ®ç—•ä½ç½®ä¼šå¯¹ä¸ä¸Š
            maskCvs.width = width * dpr;
            maskCvs.height = height * dpr;
            mCtx.scale(dpr, dpr); // ç¦»å±ä¹Ÿè¦ç¼©æ”¾

            bubbles = [];
            // æ‰‹æœºç«¯å‡å°‘æ°”æ³¡æ•°é‡ä»¥æå‡æ€§èƒ½
            const bubbleCount = width < 600 ? 60 : 120;
            for(let i=0; i<bubbleCount; i++) {
                const b = new Bubble();
                b.y = Math.random() * height;
                bubbles.push(b);
            }
        }

        function renderFogLoop() {
            fCtx.clearRect(0, 0, width, height);

            fCtx.fillStyle = 'rgba(15, 20, 30, 0.9)'; 
            fCtx.fillRect(0, 0, width, height);

            bubbles.forEach(b => {
                b.update();
                b.draw(fCtx);
            });

            fCtx.globalCompositeOperation = 'destination-out';
            // æ³¨æ„ï¼šdrawImage æ—¶è¦ç»˜åˆ¶æ•´ä¸ªç¦»å± canvas
            fCtx.drawImage(maskCvs, 0, 0, width, height);
            fCtx.globalCompositeOperation = 'source-over';

            requestAnimationFrame(renderFogLoop);
        }

        // æ“¦é™¤é€»è¾‘
        function scratch(x, y) {
            mCtx.lineCap = 'round';
            mCtx.lineJoin = 'round';
            // ç¬”åˆ·å¤§å°è‡ªé€‚åº”ï¼šæ‰‹æœºä¸Šç¨å¾®å°ä¸€ç‚¹ï¼Œç”µè„‘ä¸Šå¤§ä¸€ç‚¹
            mCtx.lineWidth = width < 600 ? 100 : 150; 
            mCtx.strokeStyle = '#000';
            
            mCtx.beginPath();
            if (lastPos) {
                mCtx.moveTo(lastPos.x, lastPos.y);
                mCtx.lineTo(x, y);
                mCtx.stroke();
            }
            // è¡¥ç‚¹
            mCtx.beginPath();
            mCtx.arc(x, y, mCtx.lineWidth / 2, 0, Math.PI*2);
            mCtx.fill();

            lastPos = {x, y};
        }


        // === 3. æ‹–å°¾ç²’å­ ===
        const EMOJIS = ['ğŸ„', 'âœ¨', 'â„ï¸', 'ğŸ', 'ğŸ””'];
        let particles = [];
        let dropThrottle = 0;

        class Particle {
            constructor(x, y) {
                this.el = document.createElement('div');
                this.el.className = 'falling-item';
                this.el.innerText = EMOJIS[Math.floor(Math.random() * EMOJIS.length)];
                document.body.appendChild(this.el);
                
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = Math.random() * -6 - 3; 
                this.grav = 0.4;
                this.rot = Math.random() * 360;
                this.life = 1.0;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.grav;
                this.rot += 5;
                this.life -= 0.02;
                this.el.style.transform = `translate(${this.x}px, ${this.y}px) rotate(${this.rot}deg)`;
                this.el.style.opacity = this.life;
            }
        }

        function loopParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.update();
                if(p.life <= 0 || p.y > height + 50) {
                    p.el.remove();
                    particles.splice(i, 1);
                }
            }
            requestAnimationFrame(loopParticles);
        }

        // === 4. äº‹ä»¶äº¤äº’ (æ ¸å¿ƒé€‚é…) ===
        const cursor = document.getElementById('cursor-glow');

        function handleInput(x, y) {
            // å…‰æ ‡è·Ÿéš (ä»…åœ¨éè§¦æ‘¸è®¾å¤‡æœ‰æ•ˆ)
            if (cursor.style.display !== 'none') {
                cursor.style.left = x + 'px';
                cursor.style.top = y + 'px';
            }
            
            scratch(x, y);

            dropThrottle++;
            if(dropThrottle % 3 === 0) { 
                particles.push(new Particle(x, y));
            }
        }

        // é¼ æ ‡äº‹ä»¶
        document.addEventListener('mousemove', e => {
            if (lastPos && Math.hypot(e.clientX - lastPos.x, e.clientY - lastPos.y) > 100) {
                lastPos = { x: e.clientX, y: e.clientY };
            }
            handleInput(e.clientX, e.clientY);
        });
        document.addEventListener('mouseup', () => lastPos = null);
        
        // è§¦æ‘¸äº‹ä»¶ (é€‚é…æ‰‹æœº)
        document.addEventListener('touchmove', e => {
            e.preventDefault(); // æå…¶é‡è¦ï¼šé˜²æ­¢æ‰‹æœºé¡µé¢æ»šåŠ¨
            const t = e.touches[0];
            // æ‰‹æœºä¸Šå¯èƒ½è·³è·ƒè¾ƒå¤§ï¼ŒåŒæ ·åšä¸€ä¸‹é˜²è·³å¤„ç†
            if (lastPos && Math.hypot(t.clientX - lastPos.x, t.clientY - lastPos.y) > 100) {
                lastPos = { x: t.clientX, y: t.clientY };
            }
            handleInput(t.clientX, t.clientY);
        }, { passive: false });

        document.addEventListener('touchend', () => lastPos = null);
        
        // çª—å£å¤§å°æ”¹å˜ (æ—‹è½¬å±å¹•/ç¼©æ”¾æµè§ˆå™¨)
        window.addEventListener('resize', () => {
            // éœ€è¦é‡æ–°è·å–å®½é«˜å¹¶é‡ç»˜
            width = window.innerWidth;
            height = window.innerHeight;
            initBackground();
            initFog();
        });

        // å¯åŠ¨
        width = window.innerWidth;
        height = window.innerHeight;
        initBackground();
        initFog();
        renderFogLoop();
        loopParticles();

    </script>
</body>
</html>