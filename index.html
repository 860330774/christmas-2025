<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Magical Christmas Eve</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #020205;
            height: 100vh;
            width: 100vw;
            cursor: none;
            user-select: none;
            touch-action: none;
            font-family: "Times New Roman", serif;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
        }

        /* Â±ÇÁ∫ßÁÆ°ÁêÜ */
        #bgCanvas { z-index: 1; }   /* ËÉåÊôØÊ†ë */
        #snowCanvas { z-index: 5; } /* ËÉåÊôØÈ£òÈõ™Â±Ç */
        #fogCanvas { z-index: 10; } /* ÈõæÊ∞îÂàÆÂàÆ‰πêÂ±Ç */

        /* --- ÊèêÁ§∫ËØ≠Ê†∑Âºè --- */
        .guide {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.9);
            font-size: 18px;
            letter-spacing: 4px;
            pointer-events: none;
            z-index: 100;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            white-space: nowrap;
            /* ÂëºÂê∏Âä®Áîª */
            animation: breathe 2s infinite ease-in-out;
            /* ÂÖ≥ÈîÆÔºöÁ°Æ‰øù transition Â±ûÊÄß‰∏ÄÁõ¥Â≠òÂú® */
            transition: opacity 1.5s ease-out;
        }

        @keyframes breathe {
            0% { opacity: 0.3; transform: translate(-50%, -50%) scale(0.95); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); text-shadow: 0 0 20px rgba(255, 215, 0, 1); }
            100% { opacity: 0.3; transform: translate(-50%, -50%) scale(0.95); }
        }

        /* ÊéâËêΩÁ≤íÂ≠ê */
        .falling-item {
            position: absolute;
            pointer-events: none;
            font-size: 24px;
            z-index: 9999;
            will-change: transform, opacity;
            filter: drop-shadow(0 0 2px rgba(255,255,255,0.3));
        }

        /* ÂÖâÊ†á */
        #cursor-glow {
            position: absolute;
            width: 60px; height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,200,0.6) 0%, rgba(0,0,0,0) 70%);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 9998;
            mix-blend-mode: screen;
            display: none;
        }
        @media (hover: hover) { #cursor-glow { display: block; } }
    </style>
</head>
<body>

    <canvas id="bgCanvas"></canvas>
    <canvas id="snowCanvas"></canvas>
    <canvas id="fogCanvas"></canvas>
    
    <div class="guide" id="guideText">‚ú¶ ÊªëÂä®Â±èÂπï ¬∑ ÁÇπ‰∫ÆÂπ≥ÂÆâÂ§ú ‚ú¶</div>
    
    <div id="cursor-glow"></div>

    <script>
        // === ÂÖ®Â±ÄÂèòÈáè ===
        let width, height, dpr;

        function resizeCanvas(canvas, ctx) {
            width = window.innerWidth;
            height = window.innerHeight;
            dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);
        }

        // === 1. ÁªèÂÖ∏ 3D ÊóãËΩ¨Ê†ë ===
        const bgCvs = document.getElementById('bgCanvas');
        const bCtx = bgCvs.getContext('2d');
        let treePoints = [];
        let rotationAngle = 0;

        class Point3D {
            constructor(type) {
                this.type = type; 
                this.init();
            }
            init() {
                const treeHeight = Math.min(width, height) * 0.75; 
                const maxRadius = treeHeight * 0.35;
                this.h = Math.random(); 
                let rBase = this.h * maxRadius;
                this.theta = Math.random() * Math.PI * 2;
                this.y = (this.h - 0.5) * treeHeight; 
                
                if (this.type === 'leaf') {
                    const r = rBase * Math.sqrt(Math.random()); 
                    this.x = Math.cos(this.theta) * r;
                    this.z = Math.sin(this.theta) * r;
                    this.size = Math.random() * 2 + 1;
                    const greens = ['#0f5020', '#186A3B', '#229954', '#2ECC71'];
                    this.color = greens[Math.floor(Math.random() * greens.length)];
                } else if (this.type === 'ornament') {
                    const r = rBase + 5; 
                    this.x = Math.cos(this.theta) * r;
                    this.z = Math.sin(this.theta) * r;
                    this.size = Math.random() * 4 + 3;
                    this.color = Math.random() > 0.5 ? '#C0392B' : '#F1C40F';
                }
            }
        }

        function initTreeScene() {
            treePoints = [];
            for(let i=0; i<1400; i++) treePoints.push(new Point3D('leaf'));
            for(let i=0; i<120; i++) treePoints.push(new Point3D('ornament'));
        }

        function renderTreeLoop() {
            bCtx.fillStyle = "#020205"; 
            bCtx.fillRect(0, 0, width, height);
            
            const gradient = bCtx.createRadialGradient(width/2, height/2, 10, width/2, height/2, Math.min(width, height)*0.6);
            gradient.addColorStop(0, 'rgba(20, 50, 30, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            bCtx.fillStyle = gradient;
            bCtx.fillRect(0, 0, width, height);

            rotationAngle += 0.005;

            const focalLength = 800;
            const centerY = height / 2 + height * 0.05; 

            treePoints.forEach(p => {
                const cos = Math.cos(rotationAngle);
                const sin = Math.sin(rotationAngle);
                p.rx = p.x * cos - p.z * sin;
                p.rz = p.z * cos + p.x * sin; 
                const scale = focalLength / (focalLength + p.rz);
                p.projX = width/2 + p.rx * scale;
                p.projY = centerY + p.y * scale;
                p.projScale = scale;
            });

            treePoints.sort((a, b) => b.rz - a.rz);

            treePoints.forEach(p => {
                const alpha = p.projScale * 0.8 + 0.2; 
                bCtx.globalAlpha = alpha;
                bCtx.beginPath();
                bCtx.fillStyle = p.color;
                bCtx.arc(p.projX, p.projY, p.size * p.projScale, 0, Math.PI*2);
                bCtx.fill();
                if (p.type === 'ornament') {
                    bCtx.fillStyle = "rgba(255,255,255,0.6)";
                    bCtx.beginPath();
                    bCtx.arc(p.projX - 1, p.projY - 1, p.size * p.projScale * 0.3, 0, Math.PI*2);
                    bCtx.fill();
                }
            });
            bCtx.globalAlpha = 1.0;

            drawStar(width/2, centerY - (Math.min(width, height)*0.75/2) - 10);
            drawClassicText();
            requestAnimationFrame(renderTreeLoop);
        }

        function drawStar(x, y) {
            bCtx.save();
            bCtx.translate(x, y);
            const scale = 1 + Math.sin(Date.now() * 0.003) * 0.1;
            bCtx.scale(scale, scale);
            bCtx.shadowBlur = 25;
            bCtx.shadowColor = "#FFD700";
            bCtx.fillStyle = "#FFFACD";
            bCtx.beginPath();
            for(let i=0; i<5; i++) {
                bCtx.lineTo(Math.cos((18+i*72)/180*Math.PI)*16, -Math.sin((18+i*72)/180*Math.PI)*16);
                bCtx.lineTo(Math.cos((54+i*72)/180*Math.PI)*7, -Math.sin((54+i*72)/180*Math.PI)*7);
            }
            bCtx.closePath();
            bCtx.fill();
            bCtx.restore();
        }

        function drawClassicText() {
            const fontSize = Math.min(width, height) * 0.08;
            bCtx.font = `italic ${fontSize}px "Times New Roman", serif`;
            bCtx.textAlign = "center";
            bCtx.textBaseline = "middle";
            const gradient = bCtx.createLinearGradient(width/2 - 100, 0, width/2 + 100, 0);
            gradient.addColorStop(0, '#BF953F');
            gradient.addColorStop(0.5, '#FCF6BA');
            gradient.addColorStop(1, '#BF953F');
            bCtx.shadowColor = "rgba(0,0,0,0.8)";
            bCtx.shadowBlur = 5;
            bCtx.fillStyle = gradient;
            bCtx.fillText("Merry Christmas", width/2, height/2 + Math.min(width, height)*0.38);
        }

        // === Êñ∞Â¢ûÔºöËÉåÊôØÈ£òÈõ™ ===
        const snowCvs = document.getElementById('snowCanvas');
        const sCtx = snowCvs.getContext('2d');
        let snowflakes = [];

        class Snowflake {
            constructor() { this.init(true); }
            init(firstTime) {
                this.x = Math.random() * width;
                this.y = firstTime ? Math.random() * height : -10;
                this.r = Math.random() * 1.5 + 0.5;
                this.spY = Math.random() * 0.5 + 0.2; 
                this.spX = (Math.random() - 0.5) * 0.3;
                this.op = Math.random() * 0.4 + 0.2;
            }
            update() {
                this.y += this.spY;
                this.x += this.spX;
                if (this.y > height + 10) this.init(false);
            }
            draw() {
                sCtx.beginPath();
                sCtx.arc(this.x, this.y, this.r, 0, Math.PI*2);
                sCtx.fillStyle = `rgba(255, 255, 255, ${this.op})`;
                sCtx.fill();
            }
        }

        function initSnow() {
            resizeCanvas(snowCvs, sCtx);
            snowflakes = [];
            // Èõ™Ëä±Êï∞Èáè‰øùÊåÅ‰πãÂâçÁöÑËÆæÁΩÆ
            const count = width < 600 ? 150 : 400; 
            for(let i=0; i<count; i++) snowflakes.push(new Snowflake());
        }

        function renderSnowLoop() {
            sCtx.clearRect(0, 0, width, height);
            snowflakes.forEach(s => { s.update(); s.draw(); });
            requestAnimationFrame(renderSnowLoop);
        }


        // === 2. ÈõæÊ∞îÂàÆÂàÆ‰πê ===
        const fogCvs = document.getElementById('fogCanvas');
        const fCtx = fogCvs.getContext('2d');
        const maskCvs = document.createElement('canvas');
        const mCtx = maskCvs.getContext('2d');
        let bubbles = [];
        let lastPos = null;
        let isFirstScratch = true; 

        class Bubble {
            constructor() { this.init(); }
            init() {
                this.x = Math.random() * width;
                this.y = height + Math.random() * 100;
                this.r = Math.random() * 6 + 2;
                this.sp = Math.random() * 0.8 + 0.2;
                this.op = Math.random() * 0.3 + 0.1;
            }
            update() {
                this.y -= this.sp;
                if(this.y < -20) this.init();
            }
            draw() {
                fCtx.beginPath();
                fCtx.arc(this.x, this.y, this.r, 0, Math.PI*2);
                fCtx.fillStyle = `rgba(255, 255, 255, ${this.op})`;
                fCtx.fill();
            }
        }

        function initFog() {
            resizeCanvas(fogCvs, fCtx);
            maskCvs.width = width * dpr;
            maskCvs.height = height * dpr;
            mCtx.scale(dpr, dpr);
            bubbles = [];
            const count = width < 600 ? 50 : 100;
            for(let i=0; i<count; i++) bubbles.push(new Bubble());
        }

        function renderFogLoop() {
            fCtx.clearRect(0, 0, width, height);
            fCtx.fillStyle = 'rgba(10, 15, 25, 0.9)'; 
            fCtx.fillRect(0, 0, width, height);
            bubbles.forEach(b => { b.update(); b.draw(); });
            fCtx.globalCompositeOperation = 'destination-out';
            fCtx.drawImage(maskCvs, 0, 0, width, height);
            fCtx.globalCompositeOperation = 'source-over';
            requestAnimationFrame(renderFogLoop);
        }

        function scratch(x, y) {
            // === ‰øÆÂ§çÁöÑÊ†∏ÂøÉ‰ª£Á†Å ===
            if (isFirstScratch) {
                const guide = document.getElementById('guideText');
                if (guide) {
                    // 1. ÂÖ≥ÈîÆÔºöÂº∫Âà∂ÂÅúÊ≠¢Âä®ÁîªÔºåÈò≤Ê≠¢ CSS ‰ºòÂÖàÁ∫ßÂÜ≤Á™Å
                    guide.style.animation = 'none';
                    // 2. Âº∫Âà∂ÊµèËßàÂô®ÈáçÁªò (Reflow)ÔºåÁ°Æ‰øùÁä∂ÊÄÅÂàáÊç¢Ë¢´ÊçïËé∑
                    void guide.offsetWidth; 
                    // 3. ËÆæÁΩÆÈÄèÊòéÂ∫¶‰∏∫0ÔºåËß¶Âèë transition
                    guide.style.opacity = '0';
                    // 4. Âª∂ËøüÁßªÈô§
                    setTimeout(() => { if(guide) guide.remove(); }, 2000);
                }
                isFirstScratch = false;
            }

            mCtx.lineCap = 'round';
            mCtx.lineJoin = 'round';
            mCtx.lineWidth = width < 600 ? 90 : 140; 
            mCtx.strokeStyle = '#000';
            mCtx.beginPath();
            if (lastPos) {
                mCtx.moveTo(lastPos.x, lastPos.y);
                mCtx.lineTo(x, y);
                mCtx.stroke();
            }
            mCtx.beginPath();
            mCtx.arc(x, y, mCtx.lineWidth/2, 0, Math.PI*2);
            mCtx.fill();
            lastPos = {x, y};
        }

        // === 3. ÊãñÂ∞æÁ≤íÂ≠ê ===
        const EMOJIS = ['üéÑ', '‚ùÑÔ∏è', 'üéÅ', 'üîî', '‚ú®'];
        let particles = [];
        let throttle = 0;

        class Particle {
            constructor(x, y) {
                this.el = document.createElement('div');
                this.el.className = 'falling-item';
                this.el.innerText = EMOJIS[Math.floor(Math.random()*EMOJIS.length)];
                document.body.appendChild(this.el);
                this.x = x + (Math.random()-0.5)*20; 
                this.y = y + (Math.random()-0.5)*20;
                this.vx = (Math.random()-0.5)*4;
                this.vy = Math.random()*-5 - 2;
                this.g = 0.4;
                this.rot = Math.random()*360;
                this.life = 1.0;
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.vy += this.g;
                this.rot += 3; this.life -= 0.02;
                this.el.style.transform = `translate(${this.x}px, ${this.y}px) rotate(${this.rot}deg)`;
                this.el.style.opacity = this.life;
            }
        }

        function loopParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.update();
                if(p.life<=0 || p.y>height+50) { p.el.remove(); particles.splice(i, 1); }
            }
            requestAnimationFrame(loopParticles);
        }

        // === 4. ‰∫§‰∫í ===
        const cursor = document.getElementById('cursor-glow');
        function handleInput(x, y) {
            if(cursor.style.display !== 'none') {
                cursor.style.left = x + 'px';
                cursor.style.top = y + 'px';
            }
            scratch(x, y);
            throttle++;
            if(throttle % 3 === 0) particles.push(new Particle(x, y));
        }

        document.addEventListener('mousemove', e => {
            if(lastPos && Math.hypot(e.clientX-lastPos.x, e.clientY-lastPos.y)>100) lastPos = {x:e.clientX, y:e.clientY};
            handleInput(e.clientX, e.clientY);
        });
        document.addEventListener('mouseup', () => lastPos = null);
        
        document.addEventListener('touchmove', e => {
            e.preventDefault();
            const t = e.touches[0];
            if(lastPos && Math.hypot(t.clientX-lastPos.x, t.clientY-lastPos.y)>100) lastPos = {x:t.clientX, y:t.clientY};
            handleInput(t.clientX, t.clientY);
        }, {passive:false});
        document.addEventListener('touchend', () => lastPos = null);

        window.addEventListener('resize', () => {
            resizeCanvas(bgCvs, bCtx);
            initTreeScene();
            
            resizeCanvas(snowCvs, sCtx); 
            initSnow();

            initFog();
        });

        // ÂêØÂä®
        resizeCanvas(bgCvs, bCtx);
        initTreeScene();
        renderTreeLoop();
        
        initSnow(); 
        renderSnowLoop();

        initFog();
        renderFogLoop();
        loopParticles();

    </script>
</body>
</html>